/*
 * hostapd / Test method for vendor specific (expanded) EAP type
 * Copyright (c) 2005-2007, Jouni Malinen <j@w1.fi>
 *
 * This software may be distributed under the terms of the BSD license.
 * See README for more details.
 */

#include "includes.h"

#include "common.h"
#include "eap_i.h"
#include "prisvc_export.h"

#define EAP_VENDOR_ID EAP_VENDOR_HOSTAP
#define EAP_VENDOR_TYPE 0xfcfbfaf9

struct eap_vendor_test_data
{
	enum
	{
		INIT,
		CONFIRM,
		SUCCESS,
		FAILURE
	} state;
	struct ACME_MPK_C *mpk;
	struct ACME_MSK_C *msk;
	struct ACME_CRED_KEY_C *cred_key;
	struct ACME_CRED_KEY_PK_C *cred_key_pk;
	struct ACME_USER_KEY_C *service_key;
	struct USER_ATTR_C *service_attr;
	struct Big_C *bid;
	struct ACME_SPK1_C *spk1;
	struct ACME_CRED_U_C *cred_s;
	struct ACME_USER_PK_C *service_key_upk;
	struct ACME_X_C *X_s;
	struct ACME_ABE_DK_X_REC_C *Dk_S_xrec;
	struct ACME_ABE_DK_f_REC_C *DK_S_frec;
	struct Big_C *z;
	struct ACME_CIPHER_C *cipher;
	struct PriSvc_MSG_B_C *msg_b;
	struct PriSvc_S_C *S_msg;
	struct PriSvc_SSK_C *ssk_s;
	struct PriSvc_C1_C *C1_msg;
	struct ACME_X_C *X_c;
};

static const char *eap_vendor_test_state_txt(int state)
{
	switch (state)
	{
	case INIT:
		return "INIT";
	case CONFIRM:
		return "CONFIRM";
	case SUCCESS:
		return "SUCCESS";
	case FAILURE:
		return "FAILURE";
	default:
		return "?";
	}
}

static void eap_vendor_test_state(struct eap_vendor_test_data *data,
								  int state)
{
	wpa_printf(MSG_DEBUG, "EAP-VENDOR-TEST: %s -> %s",
			   eap_vendor_test_state_txt(data->state),
			   eap_vendor_test_state_txt(state));
	data->state = state;
}

static void *eap_vendor_test_init(struct eap_sm *sm)
{
	struct eap_vendor_test_data *data;
	int ret;

	data = os_zalloc(sizeof(*data));
	if (data == NULL)
		return NULL;

	// system init
	wpa_printf(MSG_DEBUG, "/////////////// system setup  ////////////////////\n");
	struct ACME_MPK_C *mpk = (struct ACME_MPK_C *)malloc(sizeof(struct ACME_MPK_C));
	struct ACME_MSK_C *msk = (struct ACME_MSK_C *)malloc(sizeof(struct ACME_MSK_C));
	ret = SetUp(mpk, msk);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.SetUp Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.SetUp pass\n");

	data->mpk = mpk;
	data->msk = msk;

	struct ACME_CRED_KEY_C *cred_key = (struct ACME_CRED_KEY_C *)malloc(sizeof(struct ACME_CRED_KEY_C));
	ret = CredKeyGen(cred_key);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.CredKeyGen Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.CredKeyGen pass\n");
	data->cred_key = cred_key;

	struct ACME_CRED_KEY_PK_C *cred_key_pk = (struct ACME_CRED_KEY_PK_C *)malloc(sizeof(struct ACME_CRED_KEY_PK_C));
	memcpy(&(cred_key_pk->pk), &(cred_key->pk), sizeof(struct ABCT_CRED_KEY_PK_C));
	data->cred_key_pk = cred_key_pk;

	wpa_printf(MSG_DEBUG, "/////////////// server setup  ////////////////////\n");

	// server init
	struct ACME_USER_KEY_C *service_key = (struct ACME_USER_KEY_C *)malloc(sizeof(struct ACME_USER_KEY_C));
	ret = UserKeyGen(service_key);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.service_key KeyGen Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.service_key KeyGen pass\n");
	data->service_key = service_key;

	struct USER_ATTR_C *service_attr = (struct USER_ATTR_C *)malloc(sizeof(struct USER_ATTR_C));
	struct Big_C *bid = (struct Big_C *)malloc(sizeof(struct Big_C));
	struct ACME_SPK1_C *spk1 = (struct ACME_SPK1_C *)malloc(sizeof(struct ACME_SPK1_C));
	ret = Issue_Send(service_key, service_attr, bid, spk1);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Send service Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Send service pass\n");

	data->service_attr = service_attr;
	data->bid = bid;
	data->spk1 = spk1;

	struct ACME_CRED_U_C *cred_s = (struct ACME_CRED_U_C *)malloc(sizeof(struct ACME_CRED_U_C));
	struct ACME_USER_PK_C *service_key_upk = (struct ACME_USER_PK_C *)malloc(sizeof(struct ACME_USER_PK_C));
	memcpy(&(service_key_upk->upk), &(service_key->upk), sizeof(struct ABCT_USER_PK_C));
	ret = Issue_Issuer(cred_key, service_attr, bid, spk1, service_key_upk, cred_s);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Issuer service Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Issuer service pass\n");

	data->cred_s = cred_s;
	data->service_key_upk = service_key_upk;

	ret = Issue_Verify(cred_key_pk, cred_s, service_attr, bid, service_key);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Verify service Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Verify service pass\n");

	struct ACME_X_C *X_s = (struct ACME_X_C *)malloc(sizeof(struct ACME_X_C));

	struct ACME_ABE_DK_X_REC_C *Dk_S_xrec = (struct ACME_ABE_DK_X_REC_C *)malloc(sizeof(struct ACME_ABE_DK_X_REC_C));

	ret = DKeyGen(msk, X_s, Dk_S_xrec);

	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.DKeyGen service Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.DKeyGen service pass\n");

	data->X_s = X_s;
	data->Dk_S_xrec = Dk_S_xrec;

	struct ACME_ABE_DK_f_REC_C *DK_S_frec = (struct ACME_ABE_DK_f_REC_C *)malloc(sizeof(struct ACME_ABE_DK_f_REC_C));
	ret = PolGen(msk, DK_S_frec);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.PolGen service Erro ret =%d\n", ret);
		return 1;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.PolGen service pass\n");

	data->DK_S_frec = DK_S_frec;

	data->state = INIT;

	return data;
}

static void eap_vendor_test_reset(struct eap_sm *sm, void *priv)
{
	struct eap_vendor_test_data *data = priv;
	os_free(data->mpk);
	os_free(data->msk);
	os_free(data->cred_key);
	os_free(data->cred_key_pk);
	os_free(data->service_key);
	os_free(data->service_attr);
	os_free(data->bid);
	os_free(data->spk1);
	os_free(data->cred_s);
	os_free(data->service_key_upk);
	os_free(data->X_s);
	os_free(data->Dk_S_xrec);
	os_free(data->DK_S_frec);
	os_free(data->z);
	os_free(data->cipher);
	os_free(data->msg_b);
	os_free(data->S_msg);
	os_free(data->ssk_s);
	os_free(data->C1_msg);
	os_free(data->X_c);
	os_free(data);
}

static struct wpabuf *eap_vendor_test_buildReq(struct eap_sm *sm, void *priv,
											   u8 id)
{
	struct eap_vendor_test_data *data = priv;
	struct wpabuf *req;

	int ret;
	/*wpabuf_put_u8(req, data->state == INIT ? 1 : 3);*/
	if (data->state == INIT)
	{
		/*req = eap_msg_alloc(EAP_VENDOR_ID, EAP_VENDOR_TYPE, 
			(1+ sizeof(struct ACME_X_C) + sizeof(struct ACME_CIPHER_C) +
			sizeof(struct PriSvc_MSG_B_C)),
						EAP_CODE_REQUEST, id);*/
		req = eap_msg_alloc(EAP_VENDOR_ID, EAP_VENDOR_TYPE, 
			1491,
						EAP_CODE_REQUEST, id);
		if (req == NULL)
		{
			wpa_printf(MSG_ERROR, "EAP-VENDOR-TEST: Failed to allocate "
								"memory for request");
			return NULL;
		}
		

		struct Big_C *z = (struct Big_C *)malloc(sizeof(struct Big_C));
		wpa_printf(MSG_DEBUG, "/////////////// server broadcast  ////////////////////\n");
		struct ACME_CIPHER_C *cipher = (struct ACME_CIPHER_C *)malloc(sizeof(struct ACME_CIPHER_C));
		struct PriSvc_MSG_B_C *msg_b = (struct PriSvc_MSG_B_C *)malloc(sizeof(struct PriSvc_MSG_B_C));

		ret = Broadcast(data->mpk, data->cred_key, data->cred_s, data->service_key,
						data->service_attr, data->bid, data->X_s, cipher, msg_b, z);
		if (ret != 0)
		{
			wpa_printf(MSG_DEBUG, "prisvc.Broadcast  Erro ret =%d\n", ret);
			return NULL;
		}
		else
			wpa_printf(MSG_DEBUG, "prisvc.Broadcast  pass\n");
		data->cipher = cipher;
		data->msg_b = msg_b;
		data->z = z;

		char buf_send[65536];
		int len_send;
		memset(buf_send, 0x00, sizeof(buf_send));
		len_send = 0;
		buf_send[len_send] = 0x01;
		len_send += 1;
		memcpy(buf_send + len_send, data->X_s, sizeof(struct ACME_X_C));
		len_send += sizeof(struct ACME_X_C);
		memcpy(buf_send + len_send, data->cipher, sizeof(struct ACME_CIPHER_C));
		len_send += sizeof(struct ACME_CIPHER_C);
		memcpy(buf_send + len_send, data->msg_b, sizeof(struct PriSvc_MSG_B_C));
		len_send += sizeof(struct PriSvc_MSG_B_C);

		wpabuf_put_data(req, buf_send, 1491);
		wpa_printf(MSG_DEBUG, "%d bytes need to be sent\n", len_send);
	}
	else if (data->state == CONFIRM)
	{
		req = eap_msg_alloc(EAP_VENDOR_ID, EAP_VENDOR_TYPE, 
			(1+ sizeof(struct PriSvc_S_C) + sizeof(struct PriSvc_SSK_C)),
						EAP_CODE_REQUEST, id);
		if (req == NULL)
		{
			wpa_printf(MSG_ERROR, "EAP-VENDOR-TEST: Failed to allocate "
								"memory for request");
			return NULL;
		}

		wpa_printf(MSG_DEBUG, "/////////////// service receive and kaa  ////////////////////\n");
		data->S_msg = (struct PriSvc_S_C *)malloc(sizeof(struct PriSvc_S_C));
		data->ssk_s = (struct PriSvc_SSK_C *)malloc(sizeof(struct PriSvc_SSK_C));

		ret = AMA_S(data->mpk, data->cred_key, data->cred_s, data->service_key,
					data->z, data->service_attr, data->bid, data->Dk_S_xrec, data->DK_S_frec,
					data->X_s, data->X_c, data->C1_msg, data->S_msg, data->ssk_s);
		if (ret != 0)
		{
			wpa_printf(MSG_DEBUG, "prisvc.AMA_S  Erro ret =%d\n", ret);
			return NULL;
		}
		else
			wpa_printf(MSG_DEBUG, "prisvc.AMA_S  pass\n");
		char buf_send[65536];
		int len_send;
		memset(buf_send, 0x00, sizeof(buf_send));
		len_send = 0;
		buf_send[len_send] = 0x03;
		len_send += 1;
		memcpy(buf_send + len_send, data->S_msg, sizeof(struct PriSvc_S_C));
		len_send += sizeof(struct PriSvc_S_C);
		memcpy(buf_send + len_send, data->ssk_s, sizeof(struct PriSvc_SSK_C));
		len_send += sizeof(struct PriSvc_SSK_C);
		wpabuf_put_data(req, buf_send, len_send);
		wpa_printf(MSG_DEBUG, "%d bytes need to be sent\n", len_send);
	}

	return req;
}

static Boolean eap_vendor_test_check(struct eap_sm *sm, void *priv,
									 struct wpabuf *respData)
{
	const u8 *pos;
	size_t len;
	struct eap_vendor_test_data *data = priv;

	pos = eap_hdr_validate(EAP_VENDOR_ID, EAP_VENDOR_TYPE, respData, &len);
	if (pos == NULL || len < 1)
	{
		wpa_printf(MSG_INFO, "EAP-VENDOR-TEST: Invalid frame");
		return TRUE;
	}
	if (*pos == '2')
	{
		if (len < (1 + sizeof(struct PriSvc_C1_C) + sizeof(struct ACME_X_C)))
		{
			wpa_printf(MSG_INFO, "EAP-VENDOR-TEST: Invalid frame 2");
			return TRUE;
		}
		int len_recv = 1;
		memcpy(data->C1_msg, pos + len_recv, sizeof(struct PriSvc_C1_C));
		len_recv += sizeof(struct PriSvc_C1_C);
		memcpy(data->X_c, pos + len_recv, sizeof(struct ACME_X_C));
		len_recv += sizeof(struct ACME_X_C);
	}
	else if (*pos == '4')
	{
		if (len < (1 + sizeof(struct PriSvc_SSK_C)))
		{
			wpa_printf(MSG_INFO, "EAP-VENDOR-TEST: Invalid frame 2");
			return TRUE;
		}
	}

	return FALSE;
}

static void eap_vendor_test_process(struct eap_sm *sm, void *priv,
									struct wpabuf *respData)
{
	struct eap_vendor_test_data *data = priv;
	const u8 *pos;
	size_t len;

	pos = eap_hdr_validate(EAP_VENDOR_ID, EAP_VENDOR_TYPE, respData, &len);
	if (pos == NULL || len < 1)
		return;

	if (data->state == INIT)
	{
		if (*pos == 2)
			eap_vendor_test_state(data, CONFIRM);
		else
			eap_vendor_test_state(data, FAILURE);
	}
	else if (data->state == CONFIRM)
	{
		if (*pos == 4)
			eap_vendor_test_state(data, SUCCESS);
		else
			eap_vendor_test_state(data, FAILURE);
	}
	else
		eap_vendor_test_state(data, FAILURE);
}

static Boolean eap_vendor_test_isDone(struct eap_sm *sm, void *priv)
{
	struct eap_vendor_test_data *data = priv;
	return data->state == SUCCESS;
}

static u8 *eap_vendor_test_getKey(struct eap_sm *sm, void *priv, size_t *len)
{
	struct eap_vendor_test_data *data = priv;
	u8 *key;
	const int key_len = 64;

	if (data->state != SUCCESS)
		return NULL;

	key = os_malloc(key_len);
	if (key == NULL)
		return NULL;

	os_memset(key, 0x11, key_len / 2);
	os_memset(key + key_len / 2, 0x22, key_len / 2);
	*len = key_len;

	return key;
}

static Boolean eap_vendor_test_isSuccess(struct eap_sm *sm, void *priv)
{
	struct eap_vendor_test_data *data = priv;
	return data->state == SUCCESS;
}

int eap_server_vendor_test_register(void)
{
	struct eap_method *eap;

	eap = eap_server_method_alloc(EAP_SERVER_METHOD_INTERFACE_VERSION,
								  EAP_VENDOR_ID, EAP_VENDOR_TYPE,
								  "VENDOR-TEST");
	if (eap == NULL)
		return -1;

	eap->init = eap_vendor_test_init;
	eap->reset = eap_vendor_test_reset;
	eap->buildReq = eap_vendor_test_buildReq;
	eap->check = eap_vendor_test_check;
	eap->process = eap_vendor_test_process;
	eap->isDone = eap_vendor_test_isDone;
	eap->getKey = eap_vendor_test_getKey;
	eap->isSuccess = eap_vendor_test_isSuccess;

	return eap_server_method_register(eap);
}
