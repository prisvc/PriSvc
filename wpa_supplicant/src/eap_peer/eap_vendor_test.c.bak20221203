/*
 * EAP peer method: Test method for vendor specific (expanded) EAP type
 * Copyright (c) 2005-2015, Jouni Malinen <j@w1.fi>
 *
 * This software may be distributed under the terms of the BSD license.
 * See README for more details.
 *
 * This file implements a vendor specific test method using EAP expanded types.
 * This is only for test use and must not be used for authentication since no
 * security is provided.
 */

#include "includes.h"

#include "common.h"
#include "eap_i.h"
#include "eloop.h"
#include "prisvc_export.h"

#define EAP_VENDOR_ID EAP_VENDOR_HOSTAP
#define EAP_VENDOR_TYPE 0xfcfbfaf9

struct eap_vendor_test_data
{
	enum
	{
		INIT,
		CONFIRM,
		SUCCESS
	} state;
	int first_try;
	int test_pending_req;
	struct ACME_MPK_C *mpk;
	struct ACME_MSK_C *msk;
	struct ACME_CRED_KEY_C *cred_key;
	struct ACME_CRED_KEY_PK_C *cred_key_pk;
	struct ACME_USER_KEY_C *client_key;
	struct USER_ATTR_C *client_attr;
	struct Big_C *sid;
	struct ACME_SPK1_C *spk1;
	struct ACME_CRED_U_C *cred_c;
	struct ACME_USER_PK_C *client_key_upk;
	struct ACME_X_C *X_s;
	struct ACME_ABE_DK_X_REC_C *Dk_C_xrec;
	struct ACME_ABE_DK_f_REC_C *DK_C_frec;
	struct Big_C *z;
	struct ACME_CIPHER_C *cipher;
	struct PriSvc_MSG_B_C *msg_b;
	struct PriSvc_S_C *S_msg;
	struct PriSvc_SSK_C *ssk_c;
	struct PriSvc_SSK_C *ssk_s;
	struct PriSvc_C1_C *C1_msg;
	struct ACME_X_C *X_c;
};

static void *eap_vendor_test_init(struct eap_sm *sm)
{
	struct eap_vendor_test_data *data;
	const u8 *password;
	size_t password_len;
	int ret;

	data = os_zalloc(sizeof(*data));
	if (data == NULL)
		return NULL;
	// system init
	wpa_printf(MSG_DEBUG, "/////////////// system setup  ////////////////////\n");
	struct ACME_MPK_C *mpk = (struct ACME_MPK_C *)malloc(sizeof(struct ACME_MPK_C));
	struct ACME_MSK_C *msk = (struct ACME_MSK_C *)malloc(sizeof(struct ACME_MSK_C));

	ret = SetUp(mpk, msk);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.SetUp Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.SetUp pass\n");

	data->mpk = mpk;
	data->msk = msk;

	struct ACME_CRED_KEY_C *cred_key = (struct ACME_CRED_KEY_C *)malloc(sizeof(struct ACME_CRED_KEY_C));
	ret = CredKeyGen(cred_key);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.CredKeyGen Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.CredKeyGen pass\n");
	data->cred_key = cred_key;

	struct ACME_CRED_KEY_PK_C *cred_key_pk = (struct ACME_CRED_KEY_PK_C *)malloc(sizeof(struct ACME_CRED_KEY_PK_C));
	memcpy(&(cred_key_pk->pk), &(cred_key->pk), sizeof(struct ABCT_CRED_KEY_PK_C));
	data->cred_key_pk = cred_key_pk;

	wpa_printf(MSG_DEBUG, "/////////////// client setup  ////////////////////\n");

	struct ACME_USER_KEY_C *client_key = (struct ACME_USER_KEY_C *)malloc(sizeof(struct ACME_USER_KEY_C));
	ret = UserKeyGen(client_key);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.client_key KeyGen Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.client_key KeyGen pass\n");

	data->client_key = client_key;

	struct USER_ATTR_C *client_attr = (struct USER_ATTR_C *)malloc(sizeof(struct USER_ATTR_C));
	struct Big_C *sid = (struct Big_C *)malloc(sizeof(struct Big_C));
	struct ACME_SPK1_C *spk1 = (struct ACME_SPK1_C *)malloc(sizeof(struct ACME_SPK1_C));
	ret = Issue_Send(client_key, client_attr, sid, spk1);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Send client Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Send client pass\n");

	data->client_attr = client_attr;
	data->sid = sid;
	data->spk1 = spk1;

	struct ACME_CRED_U_C *cred_c = (struct ACME_CRED_U_C *)malloc(sizeof(struct ACME_CRED_U_C));
	struct ACME_USER_PK_C *client_key_upk = (struct ACME_USER_PK_C *)malloc(sizeof(struct ACME_USER_PK_C));
	memcpy(&(client_key_upk->upk), &(client_key->upk), sizeof(struct ABCT_USER_PK_C));
	ret = Issue_Issuer(cred_key, client_attr, sid, spk1, client_key_upk, cred_c);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Issuer client Erro ret =%d\n", ret);
		return 1;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Issuer client pass\n");

	data->cred_c = cred_c;
	data->client_key_upk = client_key_upk;

	ret = Issue_Verify(cred_key_pk, cred_c, client_attr, sid, client_key);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Verify client Erro ret =%d\n", ret);
		return 1;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.Issue_Verify client pass\n");
	struct ACME_X_C *X_c = (struct ACME_X_C *)malloc(sizeof(struct ACME_X_C));
	struct ACME_ABE_DK_X_REC_C *Dk_C_xrec = (struct ACME_ABE_DK_X_REC_C *)malloc(sizeof(struct ACME_ABE_DK_X_REC_C));
	ret = DKeyGen(msk, X_c, Dk_C_xrec);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.DKeyGen client Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.DKeyGen client pass\n");

	data->X_c = X_c;
	data->Dk_C_xrec = Dk_C_xrec;

	struct ACME_ABE_DK_f_REC_C *DK_C_frec = (struct ACME_ABE_DK_f_REC_C *)malloc(sizeof(struct ACME_ABE_DK_f_REC_C));
	ret = PolGen(msk, DK_C_frec);
	if (ret != 0)
	{
		wpa_printf(MSG_DEBUG, "prisvc.PolGen client Erro ret =%d\n", ret);
		return NULL;
	}
	else
		wpa_printf(MSG_DEBUG, "prisvc.PolGen client pass\n");

	data->DK_C_frec = DK_C_frec;

	data->state = INIT;
	data->first_try = 1;

	password = eap_get_config_password(sm, &password_len);
	data->test_pending_req = password && password_len == 7 &&
							 os_memcmp(password, "pending", 7) == 0;

	return data;
}

static void eap_vendor_test_deinit(struct eap_sm *sm, void *priv)
{
	struct eap_vendor_test_data *data = priv;
	os_free(data->mpk);
	os_free(data->msk);
	os_free(data->cred_key);
	os_free(data->cred_key_pk);
	os_free(data->client_key);
	os_free(data->client_attr);
	os_free(data->sid);
	os_free(data->spk1);
	os_free(data->cred_c);
	os_free(data->client_key_upk);
	os_free(data->X_s);
	os_free(data->Dk_C_xrec);
	os_free(data->DK_C_frec);
	os_free(data->z);
	os_free(data->cipher);
	os_free(data->msg_b);
	os_free(data->S_msg);
	os_free(data->ssk_c);
	os_free(data->ssk_s);
	os_free(data->C1_msg);
	os_free(data->X_c);
	os_free(data);
}

static void eap_vendor_ready(void *eloop_ctx, void *timeout_ctx)
{
	struct eap_sm *sm = eloop_ctx;
	wpa_printf(MSG_DEBUG, "EAP-VENDOR-TEST: Ready to re-process pending "
						  "request");
	eap_notify_pending(sm);
}

static struct wpabuf *eap_vendor_test_process(struct eap_sm *sm, void *priv,
											  struct eap_method_ret *ret,
											  const struct wpabuf *reqData)
{
	struct eap_vendor_test_data *data = priv;
	struct wpabuf *resp;
	const u8 *pos;
	size_t len;

	pos = eap_hdr_validate(EAP_VENDOR_ID, EAP_VENDOR_TYPE, reqData, &len);
	if (pos == NULL || len < 1)
	{
		ret->ignore = TRUE;
		return NULL;
	}

	if (data->state == INIT && *pos != 1)
	{
		wpa_printf(MSG_DEBUG, "EAP-VENDOR-TEST: Unexpected message "
							  "%d in INIT state",
				   *pos);
		ret->ignore = TRUE;
		return NULL;
	}

	if (data->state == CONFIRM && *pos != 3)
	{
		wpa_printf(MSG_DEBUG, "EAP-VENDOR-TEST: Unexpected message "
							  "%d in CONFIRM state",
				   *pos);
		ret->ignore = TRUE;
		return NULL;
	}

	if (data->state == SUCCESS)
	{
		wpa_printf(MSG_DEBUG, "EAP-VENDOR-TEST: Unexpected message "
							  "in SUCCESS state");
		ret->ignore = TRUE;
		return NULL;
	}

	if (data->state == CONFIRM)
	{
		if (data->test_pending_req && data->first_try)
		{
			data->first_try = 0;
			wpa_printf(MSG_DEBUG, "EAP-VENDOR-TEST: Testing "
								  "pending request");
			ret->ignore = TRUE;
			eloop_register_timeout(1, 0, eap_vendor_ready, sm,
								   NULL);
			return NULL;
		}
	}

	ret->ignore = FALSE;

	wpa_printf(MSG_DEBUG, "EAP-VENDOR-TEST: Generating Response");
	ret->allowNotifications = TRUE;

	resp = eap_msg_alloc(EAP_VENDOR_ID, EAP_VENDOR_TYPE, 65535,
						 EAP_CODE_RESPONSE, eap_get_id(reqData));
	if (resp == NULL)
		return NULL;
	int len_recv;
	if (data->state == INIT)
	{
		wpa_printf(MSG_DEBUG, "/////////////// client receive and init  ////////////////////\n");
		struct ACME_CIPHER_C *cipher = (struct ACME_CIPHER_C *)malloc(sizeof(struct ACME_CIPHER_C));
		struct PriSvc_MSG_B_C *msg_b = (struct PriSvc_MSG_B_C *)malloc(sizeof(struct PriSvc_MSG_B_C));

		len_recv = 1;
		memcpy(data->X_s, pos + len_recv, sizeof(struct ACME_X_C));
		len_recv += sizeof(struct ACME_X_C);
		memcpy(data->cipher, pos + len_recv, sizeof(struct ACME_CIPHER_C));
		len_recv += sizeof(struct ACME_CIPHER_C);
		memcpy(data->msg_b, pos + len_recv, sizeof(struct PriSvc_MSG_B_C));
		len_recv += sizeof(struct PriSvc_MSG_B_C);

		data->C1_msg = (struct PriSvc_C1_C *)malloc(sizeof(struct PriSvc_C1_C));
		ret = AMA_Cinit(data->mpk, data->cred_key, data->cred_c, data->client_key,
						data->Dk_C_xrec, data->DK_C_frec, data->X_s, data->X_c, data->client_attr,
						data->sid, data->cipher, data->msg_b, data->C1_msg);
		if (ret != 0)
		{
			wpa_printf(MSG_DEBUG, "prisvc.AMA_Cinit  Erro ret =%d\n", ret);
			ret->ignore = TRUE;
			return NULL;
		}
		else
			wpa_printf(MSG_DEBUG, "prisvc.AMA_Cinit  pass\n");

		char buf_send[65536];
		int len_send;
		memset(buf_send, 0x00, sizeof(buf_send));
		buf_send[0] = 0x02;
		len_send = 1;
		memcpy(buf_send + len_send, data->C1_msg, sizeof(struct PriSvc_C1_C));
		len_send += sizeof(struct PriSvc_C1_C);
		memcpy(buf_send + len_send, data->X_c, sizeof(struct ACME_X_C));
		len_send += sizeof(struct ACME_X_C);
		wpabuf_put_data(resp, buf_send, len_send);
		wpa_printf(MSG_DEBUG, "%d bytes need to be sent\n", len_send);

		data->state = CONFIRM;
		ret->methodState = METHOD_CONT;
		ret->decision = DECISION_FAIL;
	}
	else
	{
		wpa_printf(MSG_DEBUG, "/////////////// client receive and kaa  ////////////////////\n");

		len_recv = 1;
		memcpy(data->S_msg, pos + len_recv, sizeof(struct PriSvc_S_C));
		len_recv += sizeof(struct PriSvc_S_C);
		memcpy(data->ssk_s, pos + len_recv, sizeof(struct PriSvc_SSK_C));
		len_recv += sizeof(struct PriSvc_SSK_C);

		data->ssk_c = (struct PriSvc_SSK_C *)malloc(sizeof(struct PriSvc_SSK_C));
		ret = AMA_Cverify(data->mpk, data->cred_key, data->cred_c, data->client_key,
						  data->Dk_C_xrec, data->DK_C_frec, data->X_s, data->X_c, data->client_attr,
						  data->sid, data->C1_msg, data->S_msg, data->ssk_c);
		if (ret != 0)
		{
			wpa_printf(MSG_DEBUG, "prisvc.AMA_Cverify  Erro ret =%d\n", ret);
			ret->ignore = TRUE;
			return NULL;
		}
		else
			wpa_printf(MSG_DEBUG, "prisvc.AMA_Cverify  pass\n");

		char buf_send[65536];
		int len_send;
		memset(buf_send, 0x00, sizeof(buf_send));
		buf_send[0] = 0x04;
		len_send = 1;
		memcpy(buf_send + len_send, data->ssk_c, sizeof(struct PriSvc_SSK_C));
		len_send += sizeof(struct PriSvc_SSK_C);
		wpabuf_put_data(resp, buf_send, len_send);
		wpa_printf(MSG_DEBUG, "%d bytes need to be sent\n", len_send);

		wpa_printf(MSG_DEBUG, "/////////////// key  ////////////////////\n");
		for (int i = 0; i < 4; i++)
		{
			if (data->ssk_c->ssk.w[i] != data->ssk_s->ssk.w[i])
				wpa_printf(MSG_DEBUG, "kaa erro!\n");
		}
		wpa_printf(MSG_DEBUG, "prisvc.Kaa success!\n");
		data->state = SUCCESS;
		ret->methodState = METHOD_DONE;
		ret->decision = DECISION_UNCOND_SUCC;
	}

	return resp;
}

static Boolean eap_vendor_test_isKeyAvailable(struct eap_sm *sm, void *priv)
{
	struct eap_vendor_test_data *data = priv;
	return data->state == SUCCESS;
}

static u8 *eap_vendor_test_getKey(struct eap_sm *sm, void *priv, size_t *len)
{
	struct eap_vendor_test_data *data = priv;
	u8 *key;
	const int key_len = 64;

	if (data->state != SUCCESS)
		return NULL;

	key = os_malloc(key_len);
	if (key == NULL)
		return NULL;

	os_memset(key, 0x11, key_len / 2);
	os_memset(key + key_len / 2, 0x22, key_len / 2);
	*len = key_len;

	return key;
}

int eap_peer_vendor_test_register(void)
{
	struct eap_method *eap;

	eap = eap_peer_method_alloc(EAP_PEER_METHOD_INTERFACE_VERSION,
								EAP_VENDOR_ID, EAP_VENDOR_TYPE,
								"VENDOR-TEST");
	if (eap == NULL)
		return -1;

	eap->init = eap_vendor_test_init;
	eap->deinit = eap_vendor_test_deinit;
	eap->process = eap_vendor_test_process;
	eap->isKeyAvailable = eap_vendor_test_isKeyAvailable;
	eap->getKey = eap_vendor_test_getKey;

	return eap_peer_method_register(eap);
}
